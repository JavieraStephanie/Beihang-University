- Be careful of PC address because it's causing lots of problem
* most people are using 13:2 but try to look for more refs
- Memory not aligned:
* Because of sh and sb, DM addr display addr must be {addr[31:2], 2'b00}
- 乘除模块暂停：暂停条件可写为stall_md = (start||busy)&&md_d，其中md_d由d级流水线寄存器产生，代表d级指令为乘除类（含mfhi mthi等）；暂停方法是暂停PC和D级寄存器，清除E级寄存器，与此前的暂停一致，注意非乘除类指令不需暂停
- 增加乘除模块后要修改各转发MUX以及转发控制器，增加从M级W级的HI、LO向前转发的情况，修改供给者而不需要修改需求；暂停也需修改，与ALU视为同类即可。（有学长使用过把乘除模块结果接到ALU输出端的操作，增加额外的片选信号，就不需要对暂停转发进行修改，可以尝试）
- 自 Start 信号有效后的第 1 个 clock 上升沿开始，乘除部件开始执行运算，同时 Busy 置位为 1。
- 在运算结果保存到 HI 和 LO 后，Busy 位清除为 0。
- 当 Busy 为 1 时，mfhi、mflo、mthi、mtlo、mult、multu、div、divu 均被阻塞，即被阻塞在 IF/ID。
- 数据写入 HI 或 LO，均只需 1 个 cycle。

//D Level -> Going to write to Reg
//E Level -> Going to process ALU
//M Level -> Going to write to Mem

STALL:
* b: uses rs and rt
	BGEZ, BGEZAL, BGTZ, BLEZ, BLTZ, BLTZAL doesn't use rt
* cal_r: uses rd, rs, rt
	SLL doesn't use rs
	CLO, CLZ doesn't use rt
* cal_i: uses, rs, rt
	LUI doesn't use rs
* load: uses rt
* store: uses rt
* jalr: uses rs (opt. rd)
* jr: uses rs

//This is for all B|JR|JALR -> CAL_R because CAL_R will write the result to rd
S1: Tuse_rs == 0 & Tnew_E == 1 & rs_d == rd_e //If processing rd, going to write rs but rs == rd

//Since it's E so this is for B|JR|JALR -> B because they are using B data (means b_nort shouldn't be included?)
S2: Tuse_rs == 0 & Tnew_E == 3 & rs_d == rt_e //If processing rt, going to write rs but rs == rt

//Since it's M so this is for B|JR|JALR -> Store, Load because they are using rt data
S3: Tuse_rs == 0 & Tnew_M == 2 & rs_d == rt_m //If processing rt, going to write rs but rs == rt

//Since it's E so this is for B because B is using rt data, actually the same as T2, but this one the new one is calr, cali, load, store
S4: Tuse_rs == 1 & Tnew_E == 3 & rs_d == rt_e //If processing rt, going to write rs, but rs == rt

//This is for all B|JR|JALR -> CAL_I because CAL_I will write the result to rt
S5: Tuse_rs == 0 & Tnew_E == 2 & rs_d == rt_e //If processing rt, going to write rs, but rs == rt

//This is for all B -> CAL_R because CAL_R will write the result to rd
T1: Tuse_rt == 0 & Tnew_E == 1 & rt_d == rd_e

//Since it's E so this is for B -> B because they are using B data
T2: Tuse_rt == 0 & Tnew_E == 3 & rt_d == rt_e

//Since it's M so this is B -> Store, Load because they are using DM (rt)
T3: Tuse_rt == 0 & Tnew_M == 2 & rt_d == rt_m

//Since it's E so this is CAL_R -> B because using ALU 
T4: Tuse_rt == 1 & Tnew_E == 3 & rt_d == rt_e

//This is for all B -> CAL_I because CAL_I will write the result to rt
T5: Tuse_rt == 0 & Tnew_E == 2 & rt_d == rt_e


FORWARD:
RSD/RTD:
	0 = RData1/RData2
	1 = RegData	//cal_r|cal_i|jal|load|clzo
	2 = PC_M+8	//jal|bal
	3 = ALUOutput	//cal_r|cal_i|clzo
	4 = PC_E+8	//jal|bal

RSE/RTE:
	0 = RData1/RData2
	1 = RegData	//cal_r|cal_i|jal|load|clzo
	2 = PC_M+8	//jal|bal
	3 = ALUOutput	//cal_r|cal_i|clzo

RTM:
	0 = RegData
	1 = RData2	//cal_r|cal_i|jal|load|bal

- movn
31 - 26 = 000000
10 - 6 = 00000
5 - 0 = 001011
MOVN rd, rs, rt
if GPR[rt] != 0 then
	GPR[rd] = GPR[rs]
endif

- movz
31 - 26 = 000000
10 - 6 = 00000
5 - 0 = 001010
if GPR[rt] = 0 then
	GPR[rd] = GPR[rs]
endif

- madd
31 - 26 = 011100
15 - 11 = 0000
10 - 6 = 00000
5 - 0 = 000000
MADD rs, rt
temp = (HI || LO) + (GPR[rs] * GPR[rt])
HI = temp63..32
LO = temp31..0

- msub -> tweak mdu (Multiply and Subtract Word to Hi, Lo)
31 - 26 = 011100
15 - 11 = 0000
10 - 6 = 00000
5 - 0 = 000100
MSUB rs, rt
temp = (HI || LO) - (GPR[rs] * GPR[rt])
HI = temp63...32
LO = temp31...0

- blezals -> based on BLEZ and JAL
BLEZ rs, offset
I: target_offset = sign_extend(offset || 0^2)
   condition = GPR[rs] <= 0^GPRLEN
I+1: if condition then
	PC = PC + target_offset
     endif

JAL target
I: GPR[31] = PC + 8
I + 1: PC = PC GPRLEN-1...28 || instr_index || 0^2

- jalr -> based on JAL and JR, in the forward part, should result in 1 or 3 (PC+8)
I: temp = GPR[rs]
   GPR[rd] = PC + 8
I+1: if Config1 CA = 0 then
	PC = temp
     else
	PC = temp GPRLEN-1...1 || 0
	ISAMode = temp0
     endif

- lwso
- lhs
- lwpl